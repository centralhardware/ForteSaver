# Стратегия дедупликации транзакций

## Проблема

В PDF выписках Forte Bank **нет времени транзакции** (только дата). Это создает проблему:
- Если вы дважды купите кофе в одном кафе на одинаковую сумму в течение дня, как отличить их?
- Если загрузить ту же выписку дважды, как избежать дубликатов?
- Если у вас несколько валютных счетов (KZT, USD и т.д.), порядок транзакций может отличаться в разных выписках

## Решение

**Уникальность = (валюта_счета, порядковый_номер_в_день, хеш_транзакции)**

### Ключевое предположение

**Банк Forte сортирует транзакции по времени внутри каждого дня для каждой валюты**, даже если время не отображается в PDF.

### Как работает дедупликация

1. **Hash транзакции** - SHA-256 от всех полей транзакции (дата, тип, сумма, валюта, merchant, location и т.д.)
2. **Daily sequence** - порядковый номер транзакции внутри дня для данной валюты (0, 1, 2...)
3. **Currency** - валюта счета (KZT, USD, EUR и т.д.)

Это означает для счета в KZT:
- Первая транзакция KZT 15.10.2025 → `(KZT, sequence=0, hash=abc123...)`
- Вторая транзакция KZT 15.10.2025 → `(KZT, sequence=1, hash=def456...)`
- Третья транзакция KZT 15.10.2025 → `(KZT, sequence=2, hash=789ghi...)`

И отдельно для счета в USD:
- Первая транзакция USD 15.10.2025 → `(USD, sequence=0, hash=xyz999...)`
- Вторая транзакция USD 15.10.2025 → `(USD, sequence=1, hash=aaa111...)`

## Как работает

### База данных

```sql
CREATE UNIQUE INDEX unique_currency_sequence_hash
ON transactions(currency, daily_sequence, transaction_hash);
```

### Логика импорта

1. Парсим PDF, получаем транзакции в порядке из файла
2. Группируем транзакции по **(валюта, дата)**
3. Присваиваем порядковые номера внутри каждой группы (0, 1, 2...)
4. Вычисляем SHA-256 хеш для каждой транзакции
5. Проверяем БД: есть ли уже тройка **(валюта, daily_sequence, hash)**?
6. Импортируем только новые

## Примеры сценариев

### ✅ Сценарий 1: Повторная загрузка той же выписки

```
Первая загрузка (счет в KZT):
- (KZT, seq=0, hash=abc123) → импортирована
- (KZT, seq=1, hash=def456) → импортирована
- (KZT, seq=2, hash=789ghi) → импортирована

Вторая загрузка (тот же PDF):
- (KZT, seq=0, hash=abc123) → пропущена (дубликат по hash)
- (KZT, seq=1, hash=def456) → пропущена (дубликат по hash)
- (KZT, seq=2, hash=789ghi) → пропущена (дубликат по hash)
```

**Результат:** Дубликаты не создаются благодаря проверке hash ✅

### ✅ Сценарий 2: Две покупки кофе в один день

```
KZT счет, 15.10.2025:
- (KZT, seq=0, hash=abc111): кофе в 7-ELEVEN за 3.80 MYR в 10:00
- (KZT, seq=1, hash=def222): обед в ресторане
- (KZT, seq=2, hash=ghi333): кофе в 7-ELEVEN за 3.80 MYR в 14:00 (снова!)
```

Обе покупки кофе имеют **разные hash и sequence**, поэтому обе импортируются ✅

### ✅ Сценарий 3: Выписки за разные периоды

```
Выписка за октябрь (KZT):
- (KZT, seq=0, hash=aaa): транзакция 01.10
- (KZT, seq=1, hash=bbb): транзакция 01.10
- ...

Выписка за сентябрь-октябрь (KZT):
- (KZT, seq=0, hash=aaa): транзакция 01.10 → пропущена (тот же hash!)
- (KZT, seq=1, hash=bbb): транзакция 01.10 → пропущена (тот же hash!)
```

При повторном импорте **октябрьские транзакции будут пропущены** благодаря проверке hash ✅

### ✅ Сценарий 4: Несколько валютных счетов (ОСНОВНАЯ ПРОБЛЕМА РЕШЕНА!)

```
Выписка по счету KZT за октябрь (загружена первой):
- (KZT, seq=0, hash=aaa111): транзакция A → импортирована
- (KZT, seq=1, hash=bbb222): транзакция B → импортирована

Выписка по счету USD за октябрь (загружена второй):
- (USD, seq=0, hash=ccc333): транзакция C → импортирована (другая валюта!)
- (USD, seq=1, hash=ddd444): транзакция D → импортирована (другая валюта!)
```

Транзакции по разным валютам **НЕ конфликтуют**, так как валюта + hash входят в ключ уникальности ✅

### ⚠️ Потенциальная проблема

Если банк изменит порядок сортировки транзакций **для одной и той же валюты**:

```
Выписка A (KZT, сортировка по времени):
- (KZT, seq=0, hash=abc): кофе 7-ELEVEN
- (KZT, seq=1, hash=def): обед

Выписка B (KZT, сортировка по сумме - порядок изменен):
- (KZT, seq=0, hash=def): обед
- (KZT, seq=1, hash=abc): кофе 7-ELEVEN
```

**НО!** Благодаря hash это **НЕ ПРОБЛЕМА**:
- `(KZT, seq=0, hash=def)` - новая комбинация → импортирована
- `(KZT, seq=1, hash=abc)` - новая комбинация → импортирована
- **НО** при попытке вставки возникнет конфликт по `hash=abc` и `hash=def` если они уже есть с другими sequence
- Система просто пропустит дубликаты благодаря проверке hash

**Вывод:** Hash защищает от дубликатов даже при изменении порядка ✅

## Преимущества

✅ **Предотвращает дубликаты** при повторной загрузке выписки благодаря hash
✅ **Позволяет несколько одинаковых покупок** в один день (разные hash)
✅ **Работает с выписками за разные периоды**
✅ **Работает с несколькими валютными счетами** (KZT, USD, EUR и т.д.)
✅ **Защита от изменения порядка транзакций** благодаря hash
✅ **Не зависит от хеша файла** (можно загружать PDF с разных устройств)

## История миграций БД

Изменения применяются автоматически через Flyway при запуске бота:

```sql
-- V2__change_deduplication_strategy.sql (устаревшая)
ALTER TABLE transactions ADD COLUMN daily_sequence INTEGER;
CREATE UNIQUE INDEX unique_daily_transaction
ON transactions(transaction_date, daily_sequence);

-- V4__use_hash_for_deduplication.sql (ТЕКУЩАЯ ВЕРСИЯ)
DROP INDEX IF EXISTS unique_daily_transaction;
CREATE UNIQUE INDEX unique_currency_sequence_hash
ON transactions(currency, daily_sequence, transaction_hash);
```

## Код

См. файлы:
- `src/main/kotlin/database/StatementRepository.kt` - логика дедупликации (проверка по currency + sequence + hash)
- `src/main/kotlin/database/Tables.kt` - схема таблицы с уникальным индексом
- `src/main/resources/db/migration/V4__use_hash_for_deduplication.sql` - миграция БД
